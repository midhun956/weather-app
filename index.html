<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Weather App</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Custom font */
        body {
            font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        /* Glassmorphism effect */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Animation for results */
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Custom scrollbar for forecast */
        .forecast-scroll::-webkit-scrollbar {
            height: 6px;
        }
        .forecast-scroll::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        .forecast-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }
        .forecast-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        /* Subtle text shadow for better readability */
        .text-shadow {
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Style for the new API-based icons */
        .weather-icon-img {
            /* Adds a subtle drop shadow to make icons pop */
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.2));
        }

        /* Styles for new search results dropdown */
        .search-results-item {
            transition: background 0.2s ease-in-out;
        }
        .search-results-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<!-- Added transition for smooth background changes -->
<body class="bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900 min-h-screen text-white p-4 sm:p-8 flex justify-center items-center transition-all duration-1000">

    <!-- Main layout container -->
    <div class="w-full max-w-4xl mx-auto">
        
        <!-- Main Container -->
        <div class="glass-card rounded-2xl shadow-2xl p-6 md:p-8">
            
            <!-- Header and Search (Responsive: flex-col on mobile, sm:flex-row on small screens and up) -->
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4 mb-6">
                <h1 class="text-3xl font-bold text-shadow">Weather App</h1>
                <!-- Search wrapper for positioning results -->
                <div class="relative w-full sm:w-auto flex gap-2">
                    <div class="relative w-full sm:w-auto">
                        <input type="text" id="cityInput" placeholder="Enter city name" class="w-full sm:w-64 bg-white/20 text-white placeholder-white/70 rounded-lg px-4 py-2 border-none focus:outline-none focus:ring-2 focus:ring-blue-400 transition-all duration-300" autocomplete="off">
                        <!-- Search Results Dropdown -->
                        <div id="searchResults" class="absolute top-full left-0 w-full rounded-b-lg overflow-hidden z-10 hidden mt-1 max-h-60 overflow-y-auto bg-black/70 backdrop-blur-md border border-white/20">
                            <!-- Results will be injected here by JS -->
                        </div>
                    </div>
                    <button id="getWeather" class="bg-blue-500 hover:bg-blue-600 rounded-lg px-4 py-2 font-semibold shadow-lg transition-all duration-300 transform hover:scale-105">
                        Search
                    </button>
                    <button id="getLocation" class="bg-gray-500 hover:bg-gray-600 rounded-lg p-2.5 font-semibold shadow-lg transition-all duration-300 transform hover:scale-105" title="Get weather for my location">
                        <!-- Location Icon -->
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></svg>
                    </button>
                </div>
            </div>

            <!-- Loading Spinner -->
            <div id="loader" class="text-center py-10 hidden">
                <div class="inline-block w-12 h-12 border-4 border-white/30 border-t-white rounded-full animate-spin"></div>
                <p class="mt-4 text-lg">Fetching weather...</p>
            </div>

            <!-- Error Message -->
            <div id="errorDisplay" class="text-center py-10 bg-red-500/20 text-red-300 rounded-lg hidden fade-in">
                <p id="errorMessage" class="text-lg font-medium"></p>
            </div>

            <!-- Weather Results Container -->
            <div id="weatherContainer" class="hidden">

                <!-- Current Weather Section -->
                <div id="currentWeather" class="text-center mb-8 fade-in">
                    <!-- This content will be generated by JavaScript -->
                </div>

                <!-- Hourly Forecast Section -->
                <div id="hourlyForecast" class="fade-in mb-8">
                    <h2 class="text-2xl font-semibold mb-4 text-center sm:text-left text-shadow">Hourly Forecast</h2>
                    <!-- Responsive: Horizontal scroll on all screen sizes -->
                    <div id="hourlyForecastContainer" class="flex overflow-x-auto gap-4 pb-4 forecast-scroll">
                        <!-- This content will be generated by JavaScript -->
                    </div>
                </div>

                <!-- 5-Day Forecast Section -->
                <div id="forecast" class="fade-in">
                    <h2 class="text-2xl font-semibold mb-4 text-center sm:text-left text-shadow">5-Day Forecast</h2>
                    <!-- Responsive: Horizontal scroll on all screen sizes -->
                    <div id="forecastContainer" class="flex overflow-x-auto gap-4 pb-4 forecast-scroll">
                        <!-- This content will be generated by JavaScript -->
                    </div>
                </div>

            </div>

        </div>
    </div>

    <script>
        // API key is REMOVED from the frontend. It will be handled by the serverless function.
        
        // DOM Elements
        const bodyEl = document.querySelector('body');
        const cityInput = document.getElementById('cityInput');
        const searchResults = document.getElementById('searchResults');
        const getWeatherBtn = document.getElementById('getWeather');
        const getLocationBtn = document.getElementById('getLocation');
        const loader = document.getElementById('loader');
        const errorDisplay = document.getElementById('errorDisplay');
        const errorMessage = document.getElementById('errorMessage');
        const weatherContainer = document.getElementById('weatherContainer');
        const currentWeatherDiv = document.getElementById('currentWeather');
        const hourlyForecastContainer = document.getElementById('hourlyForecastContainer');
        const forecastContainer = document.getElementById('forecastContainer');
        
        // Dynamic Background Gradient Mapping
        const weatherBackgrounds = {
            "ClearDay": "bg-gradient-to-br from-blue-500 via-cyan-600 to-blue-700",
            "ClearNight": "bg-gradient-to-br from-gray-900 via-blue-900 to-indigo-900",
            "Clouds": "bg-gradient-to-br from-gray-600 via-gray-700 to-blue-800",
            "Rain": "bg-gradient-to-br from-gray-700 via-blue-900 to-gray-800",
            "Drizzle": "bg-gradient-to-br from-gray-600 via-blue-800 to-gray-700",
            "Snow": "bg-gradient-to-br from-blue-300 via-gray-400 to-blue-400",
            "Thunderstorm": "bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900",
            "Mist": "bg-gradient-to-br from-gray-600 via-blue-700 to-gray-600",
            "Fog": "bg-gradient-to-br from-gray-700 via-gray-600 to-gray-700",
            "Haze": "bg-gradient-to-br from-gray-500 via-orange-900 to-gray-700",
            "default": "bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900"
        };
        
        let debounceTimer;

        // Helper function to format time (for sunrise/sunset)
        function formatTime(timestamp) {
            return new Date(timestamp * 1000).toLocaleTimeString('en-US', {
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        // Debounce function
        function debounce(func, delay) {
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => func.apply(context, args), delay);
            }
        }

        // Fetch cities for autocomplete from our serverless function
        async function searchCities() {
            const query = cityInput.value.trim();
            if (query.length < 3) {
                hideSearchResults();
                return;
            }

            try {
                // Use our own serverless function proxy
                const response = await fetch(`/api/getWeather?geo=${encodeURIComponent(query)}`);
                if (!response.ok) {
                    throw new Error('City search failed');
                }
                const cities = await response.json();
                displaySearchResults(cities);
            } catch (error) {
                console.error("Error searching cities:", error);
                hideSearchResults();
            }
        }

        // Display search results
        function displaySearchResults(cities) {
            searchResults.innerHTML = '';
            const query = cityInput.value.trim(); // Get current query

            if (cities.length === 0 && query.length > 0) { // If no cities found, but user typed something
                const resultItem = document.createElement('div');
                resultItem.className = 'search-results-item p-3 cursor-pointer';
                // Show a clickable item to search for their exact text
                resultItem.innerHTML = `Search for "<strong>${query}</strong>"`; 
                resultItem.addEventListener('click', () => {
                    // We pass a simple object with the name property
                    // to match what selectCity expects.
                    selectCity({ name: query }); 
                });
                searchResults.appendChild(resultItem);
            } else {
                cities.forEach(city => {
                    const resultItem = document.createElement('div');
                    resultItem.className = 'search-results-item p-3 cursor-pointer';
                    let country = city.country || '';
                    let state = city.state || '';
                    let label = `${city.name}, ${country}`;
                    if (state) {
                        label = `${city.name}, ${state}, ${country}`;
                    }
                    resultItem.textContent = label;
                    resultItem.addEventListener('click', () => {
                        selectCity(city);
                    });
                    searchResults.appendChild(resultItem);
                });
            }
            searchResults.classList.remove('hidden');
        }

        // Handle city selection from dropdown
        function selectCity(city) {
            cityInput.value = city.name;
            hideSearchResults();
            fetchWeather(city.name);
        }

        // Hide search results
        function hideSearchResults() {
            searchResults.classList.add('hidden');
            searchResults.innerHTML = '';
        }

        // Event Listeners
        getWeatherBtn.addEventListener('click', () => {
            const city = cityInput.value.trim();
            if (city) {
                hideSearchResults();
                fetchWeather(city);
            } else {
                showError("Please enter a city name.");
            }
        });

        cityInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                getWeatherBtn.click(); // This will also hide search results
            }
        });

        // Add debounced live search to city input
        cityInput.addEventListener('input', debounce(searchCities, 300));
        
        // Hide results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#cityInput') && !e.target.closest('#searchResults')) {
                hideSearchResults();
            }
        });

        getLocationBtn.addEventListener('click', () => {
            hideSearchResults();
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    const { latitude, longitude } = position.coords;
                    fetchWeatherByCoords(latitude, longitude);
                }, () => {
                    showError("Unable to retrieve location. Please allow location access.");
                });
            } else {
                showError("Geolocation is not supported by your browser.");
            }
        });

        // Show/Hide UI functions
        function showLoader() {
            loader.classList.remove('hidden');
            weatherContainer.classList.add('hidden');
            errorDisplay.classList.add('hidden');
        }

        function hideLoader() {
            loader.classList.add('hidden');
        }

        async function showError(message) {
            hideLoader();
            hideSearchResults(); // Also hide search results on error
            
            // Try to parse the error message if it's JSON
            try {
                const errorJson = JSON.parse(message);
                errorMessage.textContent = errorJson.message || "An unknown error occurred.";
            } catch(e) {
                errorMessage.textContent = message;
            }
            
            errorDisplay.classList.remove('hidden');
            weatherContainer.classList.add('hidden');
            // Reset to default background on error
            updateBackground("default");
        }

        function showWeather() {
            hideLoader();
            errorDisplay.classList.add('hidden');
            weatherContainer.classList.remove('hidden');
        }
        
        // Update background
        function updateBackground(weatherMain, isDay = true) {
            let newBgClass;
            if (weatherMain === "Clear") {
                newBgClass = isDay ? weatherBackgrounds["ClearDay"] : weatherBackgrounds["ClearNight"];
            } else {
                newBgClass = weatherBackgrounds[weatherMain] || weatherBackgrounds["default"];
            }
            
            const allBgClasses = [...Object.values(weatherBackgrounds), weatherBackgrounds.ClearDay, weatherBackgrounds.ClearNight]
                                   .flatMap(c => c.split(' '));
            bodyEl.classList.remove(...allBgClasses);
            
            bodyEl.classList.add(...newBgClass.split(' '));
        }


        // Fetch Weather from our serverless function
        async function fetchWeather(city) {
            showLoader();
            try {
                // Fetch from our own function endpoint
                const response = await fetch(`/api/getWeather?city=${encodeURIComponent(city)}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(errorText || `City not found (Error ${response.status})`);
                }
                const { weatherData, forecastData } = await response.json();

                // Display data
                displayCurrentWeather(weatherData);
                displayHourlyForecast(forecastData);
                displayForecast(forecastData);
                showWeather();

                // Save last city to localStorage
                localStorage.setItem('lastWeatherCity', city);

            } catch (error) {
                showError(error.message);
            }
        }
        
        // Fetch Weather by Coords from our serverless function
        async function fetchWeatherByCoords(lat, lon) {
            showLoader();
            try {
                // Fetch from our own function endpoint
                const response = await fetch(`/api/getWeather?lat=${lat}&lon=${lon}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(errorText || `Weather not found (Error ${response.status})`);
                }
                const { weatherData, forecastData } = await response.json();

                // Display data
                displayCurrentWeather(weatherData);
                displayHourlyForecast(forecastData);
                displayForecast(forecastData);
                showWeather();

                // Save last city to localStorage
                localStorage.setItem('lastWeatherCity', weatherData.name);
                cityInput.value = weatherData.name;

            } catch (error) {
                showError(error.message);
            }
        }


        // Display Current Weather
        function displayCurrentWeather(data) {
            const { name, sys, main, weather, wind, dt } = data;
            const weatherMain = weather[0].main;
            const weatherDesc = weather[0].description;
            const iconCode = weather[0].icon;
            const { sunrise, sunset } = sys; // Get sunrise/sunset times
            
            const isDay = dt > sunrise && dt < sunset;
            updateBackground(weatherMain, isDay);

            const currentDate = new Date(dt * 1000).toLocaleDateString('en-US', {
                weekday: 'long',
                month: 'long',
                day: 'numeric'
            });

            currentWeatherDiv.innerHTML = `
                <h2 class="text-4xl font-bold mb-2 text-shadow">${name}, ${sys.country}</h2>
                <p class="text-lg text-white/80 mb-6 text-shadow">${currentDate}</p>
                <!-- Responsive: flex-col on mobile, md:flex-row on medium screens up -->
                <div class="flex flex-col md:flex-row items-center justify-center gap-6 md:gap-12">
                    <div class="flex items-center">
                        <!-- Use img tag for high-res OpenWeatherMap icon -->
                        <img 
                            src="https://openweathermap.org/img/wn/${iconCode}@4x.png" 
                            alt="${weatherDesc}" 
                            class="weather-icon-img w-24 h-24 md:w-32 md:h-32 -m-4 md:-m-6" 
                        />
                        <div class_="${iconCode} ml-0 text-left">
                            <p class="text-6xl font_bold text-shadow">${Math.round(main.temp)}°C</p>
                            <p class="text-xl capitalize text-white/80 text-shadow">${weatherDesc}</p>
                        </div>
                    </div>
                    
                    <!-- Responsive grid: 1 col on mobile, 3 on sm screens up -->
                    <!-- This class provides the mobile UI fix -->
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-x-6 gap-y-4 text-left text-lg">
                        <p class="text-white/80 flex items-center">
                            <!-- Feels like icon -->
                            <svg class="w-6 h-6 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0zM4.501 20.118a7.5 7.5 0 0114.998 0A17.933 17.933 0 0112 21.75c-2.676 0-5.216-.584-7.499-1.632z" />
                            </svg>
                            Feels like: <span class="font-semibold text-white ml-1.5">${Math.round(main.feels_like)}°C</span>
                        </p>
                        <p class="text-white/80 flex items-center">
                            <!-- Humidity icon (droplet) -->
                            <svg class="w-6 h-6 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 18.75a6.75 6.75 0 006.75-6.75c0-5.25-6.75-10.5-6.75-10.5s-6.75 5.25-6.75 10.5A6.75 6.75 0 0012 18.75z" />
                            </svg>
                            Humidity: <span class="font-semibold text-white ml-1.5">${main.humidity}%</span>
                        </p>
                        <p class="text-white/80 flex items-center">
                            <!-- Min/Max icon -->
                            <svg class="w-6 h-6 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 15L12 18.75 15.75 15m-7.5-6L12 5.25 15.75 9" /></svg>
                            Min/Max: <span class="font-semibold text-white ml-1.5">${Math.round(main.temp_min)}°/${Math.round(main.temp_max)}°</span>
                        </p>
                        <p class="text-white/80 flex items-center">
                            <!-- Wind icon -->
                            <svg class="w-6 h-6 mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 12 3.269 3.126A59.768 59.768 0 0 1 21.485 12 59.77 59.77 0 0 1 3.27 20.875L6 12Zm0 0h7.5" /></svg>
                             Wind: <span class="font-semibold text-white ml-1.5">${wind.speed} m/s</span>
                        </p>
                        <p class="text-white/80 flex items-center">
                            <!-- Sunrise icon -->
                            <svg class="w-6 h-6 inline-block mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0zM12 18.5A6.5 6.5 0 015.5 12H18.5A6.5 6.5 0 0112 18.5z" /></svg>
                            Sunrise: <span class="font-semibold text-white ml-1.5">${formatTime(sunrise)}</span>
                        </p>
                        <p class="text-white/80 flex items-center">
                            <!-- Sunset icon -->
                            <svg class="w-6 h-6 inline-block mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0zM12 18.5a6.5 6.5 0 006.5-6.5H5.5a6.5 6.5 0 006.5 6.5z" /></svg>
                            Sunset: <span class="font-semibold text-white ml-1.5">${formatTime(sunset)}</span>
                        </p>
                    </div>
                </div>
            `;
        }

        // New Function: Display Hourly Forecast
        function displayHourlyForecast(data) {
            hourlyForecastContainer.innerHTML = '';

            // Get the next 8 entries (24 hours)
            const hourlyData = data.list.slice(0, 8);

            hourlyData.forEach(item => {
                const { main, weather, dt } = item;
                const iconCode = weather[0].icon;
                const weatherMain = weather[0].main;

                // Format time to e.g., "1 PM"
                const time = new Date(dt * 1000).toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    hour12: true
                });

                const hourlyCard = `
                    <div class="glass-card flex-shrink-0 w-28 text-center rounded-xl p-4">
                        <p class="text-lg font-semibold mb-1">${time}</p>
                        <img 
                            src="https://openweathermap.org/img/wn/${iconCode}@2x.png" 
                            alt="${weatherMain}" 
                            class="weather-icon-img w-16 h-16 mx-auto -mt-2 -mb-1"
                        />
                        <p class="text-xl font-bold">${Math.round(main.temp)}°C</p>
                    </div>
                `;
                hourlyForecastContainer.innerHTML += hourlyCard;
            });
        }


        // Display 5-Day Forecast
        function displayForecast(data) {
            forecastContainer.innerHTML = '';
            
            // Get forecast for the next 5 days (one entry per day, around midday)
            const dailyForecasts = data.list.filter(item => {
                return item.dt_txt.includes("12:00:00");
            });

            // If no 12:00:00 data (e.g., API changed), create a simple daily list
            if (dailyForecasts.length === 0) {
                let processedDays = [];
                for (const item of data.list) {
                    const day = new Date(item.dt * 1000).toLocaleDateString('en-US', { weekday: 'short' });
                    if (!processedDays.includes(day)) {
                        dailyForecasts.push(item);
                        processedDays.push(day);
                    }
                    if (dailyForecasts.length >= 5) break;
                }
            }
            
            const forecastsToDisplay = dailyForecasts.slice(0, 5);

            forecastsToDisplay.forEach((item, i) => {
                const { main, weather, dt } = item;
                const weatherMain = weather[0].main;
                const iconCode = weather[0].icon;

                const day = new Date(dt * 1000).toLocaleDateString('en-US', { weekday: 'short' });

                const forecastCard = `
                    <div class="glass-card flex-shrink-0 w-36 text-center rounded-xl p-4">
                        <p class="text-lg font-semibold mb-1">${day}</p>
                        <!-- Use img tag for high-res OpenWeatherMap icon, scaled down -->
                        <img 
                            src="https://openweathermap.org/img/wn/${iconCode}@4x.png" 
                            alt="${weatherMain}" 
                            class="weather-icon-img w-20 h-20 mx-auto -mt-3 -mb-1"
                        />
                        <p class="text-2xl font-bold">${Math.round(main.temp)}°C</p>
                        <p class="text-sm text-white/70">${weatherMain}</p>
                    </div>
                `;
                forecastContainer.innerHTML += forecastCard;
            });
        }
        
        // On Load: Get location or load last city
        document.addEventListener('DOMContentLoaded', () => {
            const lastCity = localStorage.getItem('lastWeatherCity');
            if (lastCity) {
                cityInput.value = lastCity;
                fetchWeather(lastCity);
            } else {
                // If no last city, try to get user's location
                getLocationBtn.click();
            }
        });

    </script>
</body>
</html>

