<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Weather App</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        /* Custom font */
        body {
            font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        /* Glassmorphism effect */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        /* Animation for results */
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Custom scrollbar for forecast */
        .forecast-scroll::-webkit-scrollbar {
            height: 6px;
        }
        .forecast-scroll::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        .forecast-scroll::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
        }
        .forecast-scroll::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        /* Subtle text shadow for better readability */
        .text-shadow {
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Style for the new API-based icons */
        .weather-icon-img {
            /* Adds a subtle drop shadow to make icons pop */
            filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.2));
        }

        /* Styles for new search results dropdown */
        .search-results-item {
            transition: background 0.2s ease-in-out;
        }
        .search-results-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<!-- Added transition for smooth background changes -->
<body class="bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900 min-h-screen text-white p-4 sm:p-8 flex justify-center items-center transition-all duration-1000">

    <div class="w-full max-w-4xl mx-auto">
        
        <!-- Main Container -->
        <div class="glass-card rounded-2xl shadow-2xl p-6 md:p-8">
            
            <!-- Header and Search (Responsive: flex-col on mobile, sm:flex-row on small screens and up) -->
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4 mb-6">
                <h1 class="text-3xl font-bold text-shadow">Weather App</h1>
                <!-- Search wrapper for positioning results -->
                <div class="relative w-full sm:w-auto flex gap-2">
                    <div class="relative w-full sm:w-auto">
                        <input type="text" id="cityInput" placeholder="Enter city name" class="w-full sm:w-64 bg-white/20 text-white placeholder-white/70 rounded-lg px-4 py-2 border-none focus:outline-none focus:ring-2 focus:ring-blue-400 transition-all duration-300" autocomplete="off">
                        <!-- Search Results Dropdown -->
                        <div id="searchResults" class="absolute top-full left-0 w-full rounded-b-lg overflow-hidden z-10 hidden mt-1 max-h-60 overflow-y-auto bg-black/70 backdrop-blur-md border border-white/20">
                            <!-- Results will be injected here by JS -->
                        </div>
                    </div>
                    <button id="getWeather" class="bg-blue-500 hover:bg-blue-600 rounded-lg px-4 py-2 font-semibold shadow-lg transition-all duration-300 transform hover:scale-105">
                        Search
                    </button>
                    <button id="getLocation" class="bg-gray-500 hover:bg-gray-600 rounded-lg p-2.5 font-semibold shadow-lg transition-all duration-300 transform hover:scale-105" title="Get weather for my location">
                        <!-- Location Icon -->
                        <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></svg>
                    </button>
                </div>
            </div>

            <!-- Loading Spinner -->
            <div id="loader" class="text-center py-10 hidden">
                <div class="inline-block w-12 h-12 border-4 border-white/30 border-t-white rounded-full animate-spin"></div>
                <p class="mt-4 text-lg">Fetching weather...</p>
            </div>

            <!-- Error Message -->
            <div id="errorDisplay" class="text-center py-10 bg-red-500/20 text-red-300 rounded-lg hidden fade-in">
                <p id="errorMessage" class="text-lg font-medium"></p>
            </div>

            <!-- Weather Results Container -->
            <div id="weatherContainer" class="hidden">

                <!-- Current Weather Section -->
                <div id="currentWeather" class="text-center mb-8 fade-in">
                    <!-- This content will be generated by JavaScript -->
                </div>

                <!-- 5-Day Forecast Section -->
                <div id="forecast" class="fade-in">
                    <h2 class="text-2xl font-semibold mb-4 text-center sm:text-left text-shadow">5-Day Forecast</h2>
                    <!-- Responsive: Horizontal scroll on all screen sizes -->
                    <div id="forecastContainer" class="flex overflow-x-auto gap-4 pb-4 forecast-scroll">
                        <!-- This content will be generated by JavaScript -->
                    </div>
                </div>

            </div>

        </div>
    </div>

    <script>
        // Your original API key
        const apiKey = 'f8f4160768dd0be1b96fcd82afa8737b';
        
        // DOM Elements
        const bodyEl = document.querySelector('body');
        const cityInput = document.getElementById('cityInput');
        const searchResults = document.getElementById('searchResults');
        const getWeatherBtn = document.getElementById('getWeather');
        const getLocationBtn = document.getElementById('getLocation');
        const loader = document.getElementById('loader');
        const errorDisplay = document.getElementById('errorDisplay');
        const errorMessage = document.getElementById('errorMessage');
        const weatherContainer = document.getElementById('weatherContainer');
        const currentWeatherDiv = document.getElementById('currentWeather');
        const forecastContainer = document.getElementById('forecastContainer');
        
        // Dynamic Background Gradient Mapping
        const weatherBackgrounds = {
            "ClearDay": "bg-gradient-to-br from-blue-500 via-cyan-600 to-blue-700",
            "ClearNight": "bg-gradient-to-br from-gray-900 via-blue-900 to-indigo-900",
            "Clouds": "bg-gradient-to-br from-gray-600 via-gray-700 to-blue-800",
            "Rain": "bg-gradient-to-br from-gray-700 via-blue-900 to-gray-800",
            "Drizzle": "bg-gradient-to-br from-gray-600 via-blue-800 to-gray-700",
            "Snow": "bg-gradient-to-br from-blue-300 via-gray-400 to-blue-400",
            "Thunderstorm": "bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900",
            "Mist": "bg-gradient-to-br from-gray-600 via-blue-700 to-gray-600",
            "Fog": "bg-gradient-to-br from-gray-700 via-gray-600 to-gray-700",
            "Haze": "bg-gradient-to-br from-gray-500 via-orange-900 to-gray-700",
            "default": "bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900"
        };
        
        let debounceTimer;

        // Debounce function
        function debounce(func, delay) {
            return function() {
                const context = this;
                const args = arguments;
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => func.apply(context, args), delay);
            }
        }

        // Fetch cities for autocomplete
        async function searchCities() {
            const query = cityInput.value.trim();
            if (query.length < 3) {
                hideSearchResults();
                return;
            }

            try {
                // Use the Geo API for city suggestions
                const response = await fetch(`https://api.openweathermap.org/geo/1.0/direct?q=${query}&limit=5&appid=${apiKey}`);
                if (!response.ok) {
                    throw new Error('City search failed');
                }
                const cities = await response.json();
                displaySearchResults(cities);
            } catch (error) {
                console.error("Error searching cities:", error);
                hideSearchResults();
            }
        }

        // Display search results
        function displaySearchResults(cities) {
            searchResults.innerHTML = '';
            const query = cityInput.value.trim(); // Get current query

            if (cities.length === 0 && query.length > 0) { // If no cities found, but user typed something
                const resultItem = document.createElement('div');
                resultItem.className = 'search-results-item p-3 cursor-pointer';
                // Show a clickable item to search for their exact text
                resultItem.innerHTML = `Search for "<strong>${query}</strong>"`; 
                resultItem.addEventListener('click', () => {
                    // We pass a simple object with the name property
                    // to match what selectCity expects.
                    selectCity({ name: query }); 
                });
                searchResults.appendChild(resultItem);
            } else {
                cities.forEach(city => {
                    const resultItem = document.createElement('div');
                    resultItem.className = 'search-results-item p-3 cursor-pointer';
                    let country = city.country || '';
                    let state = city.state || '';
                    let label = `${city.name}, ${country}`;
                    if (state) {
                        label = `${city.name}, ${state}, ${country}`;
                    }
                    resultItem.textContent = label;
                    resultItem.addEventListener('click', () => {
                        selectCity(city);
                    });
                    searchResults.appendChild(resultItem);
                });
            }
            searchResults.classList.remove('hidden');
        }

        // Handle city selection from dropdown
        function selectCity(city) {
            cityInput.value = city.name;
            hideSearchResults();
            fetchWeather(city.name);
        }

        // Hide search results
        function hideSearchResults() {
            searchResults.classList.add('hidden');
            searchResults.innerHTML = '';
        }

        // Event Listeners
        getWeatherBtn.addEventListener('click', () => {
            const city = cityInput.value.trim();
            if (city) {
                hideSearchResults();
                fetchWeather(city);
            } else {
                showError("Please enter a city name.");
            }
        });

        cityInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                getWeatherBtn.click(); // This will also hide search results
            }
        });

        // Add debounced live search to city input
        cityInput.addEventListener('input', debounce(searchCities, 300));
        
        // Hide results when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#cityInput') && !e.target.closest('#searchResults')) {
                hideSearchResults();
            }
        });

        getLocationBtn.addEventListener('click', () => {
            hideSearchResults();
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    const { latitude, longitude } = position.coords;
                    fetchWeatherByCoords(latitude, longitude);
                }, () => {
                    showError("Unable to retrieve location. Please allow location access.");
                });
            } else {
                showError("Geolocation is not supported by your browser.");
            }
        });

        // Show/Hide UI functions
        function showLoader() {
            loader.classList.remove('hidden');
            weatherContainer.classList.add('hidden');
            errorDisplay.classList.add('hidden');
        }

        function hideLoader() {
            loader.classList.add('hidden');
        }

        function showError(message) {
            hideLoader();
            hideSearchResults(); // Also hide search results on error
            errorMessage.textContent = message;
            errorDisplay.classList.remove('hidden');
            weatherContainer.classList.add('hidden');
            // Reset to default background on error
            updateBackground("default");
        }

        function showWeather() {
            hideLoader();
            errorDisplay.classList.add('hidden');
            weatherContainer.classList.remove('hidden');
        }
        
        // Update background
        function updateBackground(weatherMain, isDay = true) {
            let newBgClass;
            if (weatherMain === "Clear") {
                newBgClass = isDay ? weatherBackgrounds["ClearDay"] : weatherBackgrounds["ClearNight"];
            } else {
                newBgClass = weatherBackgrounds[weatherMain] || weatherBackgrounds["default"];
            }
            
            const allBgClasses = [...Object.values(weatherBackgrounds), weatherBackgrounds.ClearDay, weatherBackgrounds.ClearNight]
                                   .flatMap(c => c.split(' '));
            bodyEl.classList.remove(...allBgClasses);
            
            bodyEl.classList.add(...newBgClass.split(' '));
        }


        // Fetch Weather from API
        async function fetchWeather(city) {
            showLoader();
            try {
                // Fetch current weather
                const weatherResponse = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${apiKey}&units=metric`);
                if (!weatherResponse.ok) {
                    throw new Error(`City not found (Error ${weatherResponse.status})`);
                }
                const weatherData = await weatherResponse.json();

                // Fetch 5-day forecast
                const forecastResponse = await fetch(`https://api.openweathermap.org/data/2.5/forecast?q=${city}&appid=${apiKey}&units=metric`);
                if (!forecastResponse.ok) {
                    throw new Error(`Forecast not found (Error ${forecastResponse.status})`);
                }
                const forecastData = await forecastResponse.json();

                // Display data
                displayCurrentWeather(weatherData);
                displayForecast(forecastData);
                showWeather();

                // Save last city to localStorage
                localStorage.setItem('lastWeatherCity', city);

            } catch (error) {
                showError(error.message);
            }
        }
        
        // Fetch Weather by Coords
        async function fetchWeatherByCoords(lat, lon) {
            showLoader();
            try {
                // Fetch current weather
                const weatherResponse = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`);
                if (!weatherResponse.ok) {
                    throw new Error(`Weather not found for your location (Error ${weatherResponse.status})`);
                }
                const weatherData = await weatherResponse.json();

                // Fetch 5-day forecast
                const forecastResponse = await fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`);
                if (!forecastResponse.ok) {
                    throw new Error(`Forecast not found for your location (Error ${forecastResponse.status})`);
                }
                const forecastData = await forecastResponse.json();

                // Display data
                displayCurrentWeather(weatherData);
                displayForecast(forecastData);
                showWeather();

                // Save last city to localStorage
                localStorage.setItem('lastWeatherCity', weatherData.name);
                cityInput.value = weatherData.name;


            } catch (error) {
                showError(error.message);
            }
        }


        // Display Current Weather
        function displayCurrentWeather(data) {
            const { name, sys, main, weather, wind, dt } = data;
            const weatherMain = weather[0].main;
            const weatherDesc = weather[0].description;
            const iconCode = weather[0].icon;
            
            const isDay = dt > sys.sunrise && dt < sys.sunset;

            updateBackground(weatherMain, isDay);

            const currentDate = new Date(dt * 1000).toLocaleDateString('en-US', {
                weekday: 'long',
                month: 'long',
                day: 'numeric'
            });

            currentWeatherDiv.innerHTML = `
                <h2 class="text-4xl font-bold mb-2 text-shadow">${name}, ${sys.country}</h2>
                <p class="text-lg text-white/80 mb-6 text-shadow">${currentDate}</p>
                <!-- Responsive: flex-col on mobile, md:flex-row on medium screens up -->
                <div class="flex flex-col md:flex-row items-center justify-center gap-6 md:gap-12">
                    <div class="flex items-center">
                        <!-- Use img tag for high-res OpenWeatherMap icon -->
                        <img 
                            src="https://openweathermap.org/img/wn/${iconCode}@4x.png" 
                            alt="${weatherDesc}" 
                            class="weather-icon-img w-24 h-24 md:w-32 md:h-32 -m-4 md:-m-6" 
                        />
                        <div class_="${iconCode} ml-0 text-left">
                            <p class="text-6xl font_bold text-shadow">${Math.round(main.temp)}°C</p>
                            <p class="text-xl capitalize text-white/80 text-shadow">${weatherDesc}</p>
                        </div>
                    </div>
                    <div class="grid grid-cols-2 gap-x-8 gap-y-4 text-left text-lg">
                        <p class="text-white/80">Feels like: <span class="font-semibold text-white">${Math.round(main.feels_like)}°C</span></p>
                        <p class="text-white/80">Humidity: <span class="font-semibold text-white">${main.humidity}%</span></p>
                        <p class="text-white/80">Min/Max: <span class="font-semibold text-white">${Math.round(main.temp_min)}°/${Math.round(main.temp_max)}°</span></p>
                        <p class="text-white/80">Wind: <span class="font-semibold text-white">${wind.speed} m/s</span></p>
                    </div>
                </div>
            `;
        }

        // Display 5-Day Forecast
        function displayForecast(data) {
            forecastContainer.innerHTML = '';
            
            // Get forecast for the next 5 days (one entry per day, around midday)
            const dailyForecasts = data.list.filter(item => {
                return item.dt_txt.includes("12:00:00");
            });

            // If no 12:00:00 data (e.g., API changed), create a simple daily list
            if (dailyForecasts.length === 0) {
                let processedDays = [];
                for (const item of data.list) {
                    const day = new Date(item.dt * 1000).toLocaleDateString('en-US', { weekday: 'short' });
                    if (!processedDays.includes(day)) {
                        dailyForecasts.push(item);
                        processedDays.push(day);
                    }
                    if (dailyForecasts.length >= 5) break;
                }
            }
            
            const forecastsToDisplay = dailyForecasts.slice(0, 5);

            forecastsToDisplay.forEach((item, i) => {
                const { main, weather, dt } = item;
                const weatherMain = weather[0].main;
                const iconCode = weather[0].icon;

                const day = new Date(dt * 1000).toLocaleDateString('en-US', { weekday: 'short' });

                const forecastCard = `
                    <div class="glass-card flex-shrink-0 w-36 text-center rounded-xl p-4">
                        <p class="text-lg font-semibold mb-1">${day}</p>
                        <!-- Use img tag for high-res OpenWeatherMap icon, scaled down -->
                        <img 
                            src="https://openweathermap.org/img/wn/${iconCode}@4x.png" 
                            alt="${weatherMain}" 
                            class="weather-icon-img w-20 h-20 mx-auto -mt-3 -mb-1"
                        />
                        <p class="text-2xl font-bold">${Math.round(main.temp)}°C</p>
                        <p class="text-sm text-white/70">${weatherMain}</p>
                    </div>
                `;
                forecastContainer.innerHTML += forecastCard;
            });
        }
        
        // On Load: Get location or load last city
        document.addEventListener('DOMContentLoaded', () => {
            const lastCity = localStorage.getItem('lastWeatherCity');
            if (lastCity) {
                cityInput.value = lastCity;
                fetchWeather(lastCity);
            } else {
                // If no last city, try to get user's location
                getLocationBtn.click();
            }
        });

    </script>
</body>
</html>



